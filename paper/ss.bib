% Encoding: UTF-8

@Article{Gaunt2016,
  author    = {Alexander L. Gaunt and Marc Brockschmidt and Rishabh Singh and Nate Kushman and Pushmeet Kohli and Jonathan Taylor and Daniel Tarlow},
  title     = {TerpreT: {A} Probabilistic Programming Language for Program Induction},
  journal   = {CoRR},
  year      = {2016},
  volume    = {abs/1608.04428},
  url       = {http://arxiv.org/abs/1608.04428},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/corr/GauntBSKKTT16},
  timestamp = {Fri, 02 Sep 2016 17:46:24 +0200},
}

@Article{Gulwani2011,
  author     = {Gulwani, Sumit},
  title      = {Automating String Processing in Spreadsheets Using Input-output Examples},
  journal    = {SIGPLAN Not.},
  year       = {2011},
  volume     = {46},
  number     = {1},
  month      = jan,
  pages      = {317--330},
  issn       = {0362-1340},
  doi        = {10.1145/1925844.1926423},
  url        = {http://doi.acm.org/10.1145/1925844.1926423},
  acmid      = {1926423},
  address    = {New York, NY, USA},
  issue_date = {January 2011},
  keywords   = {program synthesis, programming by example (pbe), spreadsheet programming, string manipulation, user intent, version space algebra},
  numpages   = {14},
  publisher  = {ACM},
}

@PhdThesis{Helmuth2015,
  author      = {Thomas Helmuth},
  title       = {General Program Synthesis from Examples Using Genetic Programming with Parent Selection Based on Random Lexicographic Orderings of Test Cases},
  institution = {University of Massachusetts, Amherst},
  year        = {2015},
  date        = {September, 2015},
  type        = {{Ph.D.} dissertation},
  url         = {http://scholarworks.umass.edu/dissertations_2/465/},
}

@InCollection{Helmuth2015a,
  author    = {Thomas Helmuth and Nicholas Freitag McPhee and Lee Spector},
  title     = {Lexicase selection for program synthesis: a diversity analysis},
  booktitle = {Genetic Programming Theory and Practice XIII},
  date      = {2015},
  series    = {Genetic and Evolutionary Computation},
  publisher = {Springer},
  pubstate  = {In press},
  noeditor  = {?},
}

@InProceedings{Helmuth2015b,
  author    = {Helmuth, Thomas and Spector, Lee},
  title     = {General Program Synthesis Benchmark Suite},
  booktitle = {Proceedings of the 2015 Annual Conference on Genetic and Evolutionary Computation},
  year      = {2015},
  series    = {GECCO '15},
  publisher = {ACM},
  location  = {Madrid, Spain},
  isbn      = {978-1-4503-3472-3},
  pages     = {1039--1046},
  doi       = {10.1145/2739480.2754769},
  url       = {http://doi.acm.org/10.1145/2739480.2754769},
  acmid     = {2754769},
  address   = {New York, NY, USA},
  keywords  = {benchmarks, genetic programming, program synthesis},
  numpages  = {8},
}

@Article{Helmuth2015c,
  author   = {Thomas Helmuth and Lee Spector and James Matheson},
  title    = {Solving Uncompromising Problems with Lexicase Selection},
  journal  = {IEEE Transactions on Evolutionary Computation},
  year     = {2015},
  volume   = {19},
  number   = {5},
  month    = oct,
  pages    = {630--643},
  issn     = {1089-778X},
  doi      = {doi:10.1109/TEVC.2014.2362729},
  url      = {http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6920034},
  abstract = {We describe a broad class of problems, called
	uncompromising problems, characterised by the
	requirement that solutions must perform optimally on
	each of many test cases. Many of the problems that have
	long motivated genetic programming research, including
	the automation of many traditional programming tasks,
	are uncompromising. We describe and analyse the
	recently proposed lexicase parent selection algorition
	and show that it can facilitate the solution of
	uncompromising problems by genetic programming. Unlike
	most traditional parent selection techniques, lexicase
	selection does not base selection on a fitness value
	that is aggregated over all test cases; rather, it
	considers test cases one at a time in random order. We
	present results comparing lexicase selection to more
	traditional parent selection methods, including
	standard tournament selection and implicit fitness
	sharing, on four uncompromising problems: finding terms
	in finite algebras, designing digital multipliers,
	counting words in files, and performing symbolic
	regression of the factorial function. We provide
	evidence that lexicase selection maintains higher
	levels of population diversity than other selection
	methods, which may partially explain its utility as a
	parent selection algorithm in the context of
	uncompromising problems.},
  doi-url  = {http://dx.doi.org/10.1109/TEVC.2014.2362729},
  keywords = {genetic algorithms, genetic programming, parent selection, lexicase selection, tournament selection, PushGP},
  notes    = {also known as \cite{6920034}},
  size     = {14 pages},
}

@Misc{Katayama2013,
  author       = {Susumu Katayama},
  title        = {MagicHaskeller on the Web: Automated Programming as a Service},
  year         = {2013},
  howpublished = {haskell-symposium},
  abstract     = {The proposed demonstration will present our Web-based automatic programming tool, named MAGICHASKELLER ON THE WEB, which can help casual programming in Haskell. We will show how simple to use the tool is, and then evaluates its ability.},
  keywords     = {Automatic programming, Inductive functional programming, Web application},
}

@Misc{Kitzelmann2009,
  author   = {Emanuel Kitzelmann},
  title    = {Inductive Programming A Survey of Program Synthesis Techniques},
  year     = {2009},
  abstract = {Inductive programming—the use of inductive reasoning methods for programming, algorithm design, and software development—is a currently emerging research field. A major subfield is inductive program synthesis, the (semi-)automatic construction of programs from exemplary behavior. Inductive program synthesis is not a unified research field until today but scattered over several different established research fields such as machine learning, inductive logic programming, genetic programming, and functional programming. This impedes an exchange of theory and techniques and, as a consequence, a progress of inductive programming. In this paper we survey theoretical results and methods of inductive program synthesis that have been developed in different research fields until today.},
}

@InProceedings{Spector2005,
  author            = {Lee Spector and Jon Klein and Maarten Keijzer},
  title             = {The {Push3} execution stack and the evolution of control},
  booktitle         = {{GECCO 2005}: Proceedings of the 2005 conference on Genetic and evolutionary computation},
  year              = {2005},
  publisher         = {ACM Press},
  isbn              = {1-59593-010-8},
  pages             = {1689--1696},
  doi               = {doi:10.1145/1068009.1068292},
  url               = {http://www.cs.bham.ac.uk/~wbl/biblio/gecco2005/docs/p1689.pdf},
  abstract          = {One of Push's attractive features in this context is
	its transparent support for the expression and
	evolution of modular architectures and complex control
	structures, achieved through explicit code
	self-manipulation. The latest version of Push, Push3,
	enhances this feature by permitting explicit
	manipulation of an execution stack that contains the
	expressions that are queued for execution in the
	interpreter. presents a series of examples in which
	Push3 was used with a simple genetic programming system
	(PushGP) to evolve programs with non-trivial control
	structures.},
  address           = {Washington DC, USA},
  keywords          = {genetic algorithms, genetic programming, combinators, experimentation, exponentiation, factorial, Fibonacci sequence, iteration, languages, parity, push, recursion, reversing a list, sorting, stack-based genetic programming},
  notes             = {GECCO-2005 A joint meeting of the fourteenth international conference on genetic algorithms (ICGA-2005) and the tenth annual genetic programming conference (GP-2005). ACM Order Number 910052 Cited by \cite{eurogp06:AgapitosLucas} EXEC stack. Combinators. Reentrant p1691 'the re-entrant interpreter allows for the controlled execution of a particular number of instructions per time-step.' Reversing a list. Factorial. Fibonacci. Parity. Powers of two, integer exponentiation Expt(2,n). Sorting a list.},
  organisation      = {ACM SIGEVO (formerly ISGEC)},
  publisher_address = {New York, NY, 10286-1405, USA},
}

@Article{Spector2002,
  author   = {Lee Spector and Alan Robinson},
  title    = {Genetic Programming and Autoconstructive Evolution with the Push Programming Language},
  journal  = {Genetic Programming and Evolvable Machines},
  year     = {2002},
  volume   = {3},
  number   = {1},
  month    = mar,
  pages    = {7--40},
  issn     = {1389-2576},
  doi      = {doi:10.1023/A:1014538503543},
  url      = {http://hampshire.edu/lspector/pubs/push-gpem-final.pdf},
  abstract = {Push is a programming language designed for the
	expression of evolving programs within an evolutionary
	computation system. This article describes Push and
	illustrates some of the opportunities that it presents
	for evolutionary computation. Two evolutionary
	computation systems, PushGP and Pushpop, are described
	in detail. PushGP is a genetic programming system that
	evolves Push programs to solve computational problems.
	Pushpop, an ?autoconstructive evolution? system, also
	evolves Push programs but does so while simultaneously
	evolving its own evolutionary mechanisms.},
  keywords = {genetic algorithms, genetic programming, artificial life, modularity, programming languages, self-adaptation},
  notes    = {Article ID: 395988},
}

@Book{Koza1992,
  author    = {John R. Koza},
  title     = {Genetic Programming: On the Programming of Computers by Means of Natural Selection},
  year      = {1992},
  publisher = {MIT Press},
  isbn      = {0-262-11170-5},
  url       = {http://mitpress.mit.edu/books/genetic-programming},
  abstract  = {Overview Genetic programming may be more powerful than
		 neural networks and other machine learning techniques,
		 able to solve problems in a wider range of disciplines.
		 In this ground-breaking book, John Koza shows how this
		 remarkable paradigm works and provides substantial
		 empirical evidence that solutions to a great variety of
		 problems from many different fields can be found by
		 genetically breeding populations of computer programs.
		 Genetic Programming contains a great many worked
		 examples and includes a sample computer code that will
		 allow readers to run their own programs. In getting
		 computers to solve problems without being explicitly
		 programmed, Koza stresses two points: that seemingly
		 different problems from a variety of fields can be
		 reformulated as problems of program induction, and that
		 the recently developed genetic programming paradigm
		 provides a way to search the space of possible computer
		 programs for a highly fit individual computer program
		 to solve the problems of program induction. Good
		 programs are found by evolving them in a computer
		 against a fitness measure instead of by sitting down
		 and writing them. John R. Koza is Consulting Associate
		 Professor in the Computer Science Department at
		 Stanford University. Endorsements The research reported
		 in this book is a tour de force. For the first time,
		 since the idea was bandied about in the 1940s and early
		 1950s, we have a non-trivial, nontailored set of
		 examples of automatic programming. -- John Holland},
  address   = {Cambridge, MA, USA},
  keywords  = {genetic algorithms, genetic programming, text book},
}

@Article{Perelman2014,
  author    = {Daniel Perelman and Sumit Gulwani and Dan Grossman and Peter Provost},
  title     = {Test-driven synthesis},
  journal   = {ACM SIGPLAN Notices},
  year      = {2014},
  volume    = {49},
  number    = {6},
  month     = {6},
  pages     = {408--418},
  issn      = {1523-2867},
  doi       = {10.1145/2594291.2594297},
  keywords  = {End-user programming, Program synthesis, Test driven development},
  publisher = {Association for Computing Machinery (ACM)},
}

@InBook{Katayama2008,
  author    = {Katayama, Susumu},
  title     = {Efficient Exhaustive Generation of Functional Programs Using Monte-Carlo Search with Iterative Deepening},
  booktitle = {PRICAI 2008: Trends in Artificial Intelligence: 10th Pacific Rim International Conference on Artificial Intelligence, Hanoi, Vietnam, December 15-19, 2008. Proceedings},
  year      = {2008},
  editor    = {Ho, Tu-Bao and Zhou, Zhi-Hua},
  publisher = {Springer Berlin Heidelberg},
  isbn      = {978-3-540-89197-0},
  pages     = {199--210},
  doi       = {10.1007/978-3-540-89197-0_21},
  url       = {http://dx.doi.org/10.1007/978-3-540-89197-0_21},
  address   = {Berlin, Heidelberg},
}

@Article{Katayama2005,
  author        = {Katayama, Susumu},
  title         = {Systematic search for lambda expressions.},
  journal       = {Trends in functional programming},
  year          = {2005},
  volume        = {6},
  pages         = {111--126},
  __markedentry = {[mm94978:]},
}

@InCollection{Katayama2010,
  author        = {Katayama, Susumu},
  title         = {Recent Improvements of MagicHaskeller},
  booktitle     = {Approaches and Applications of Inductive Programming},
  year          = {2010},
  date          = {2010-01-01},
  publisher     = {Springer},
  isbn          = {978-3-642-11930-9},
  doi           = {10.1007/978-3-642-11931-6_9},
  url           = {http://dx.doi.org/10.1007/978-3-642-11931-6_9},
  __markedentry = {[mm94978:6]},
  abstract      = {MagicHaskeller is our inductive functional programming library based on systematic search. In this paper we introduce two recent improvements to MagicHaskeller, i.e. 1) clarification and extension to arbitrary-rank polymorphism of its algorithm, and 2) efficiency improvement in its filtration algorithm that removes redundancy in the search results.},
  month         = jan,
}

@Comment{jabref-meta: databaseType:biblatex;}
